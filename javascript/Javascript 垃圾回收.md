# [GC算法](https://zhuanlan.zhihu.com/p/362348363)

## WHAT GC

GC 就是垃圾回收机制的简写
GC可以找到内存中的垃圾、并释放和回收空间

## GC中的垃圾

程序中不再需要使用的对象
程序中不能再访问到的对象

## WHAT GC算法

GC 是一种机制，垃圾回收器完成具体的工作
工作的内容就是查找垃圾释放空间、回收空间
算法就是工作时查找和回收所遵循的规则

## 常见GC算法

### 引用计数

**原理**
内部通过引用计数器维护当前对象的引用数，判断当前引用数是否为 0，决定是否开始 GC 工作[为 0 时则开始工作]

> 引用计数器 => 引用关系发生改变时会修改当前对象所对应的引用数字，引用数字为 0 时立即回收

```js
const obj1 = { age: 1 };
const obj2 = { age: 2 };
const obj3 = { age: 3 };
const objAge = [obj1.age, obj2.age, obj3.age]; // 由于当前对象引用了obj*中的值，所以obj*引用数字不会变为0，即不会回收
function func() {
  const a = 1,
    b = 2;
}
func(); // 函数执行完成后释放a,b
```

**优缺点**

- 优点

  1. 发现垃圾立即回收
  2. 最大限度减少程序暂停【说明 1】

- 缺点

  1. 无法回收循环引用的对象【栗子】

  2. 时间开销大【说明 2】

> 说明:
>
> 1. 当发现垃圾的时候会进行及时清理释放空间，所以保证了内存空间的大小，不会因此导致程序的暂停
> 2. 需要维护对象的数值修改，当对象很多的情况下，所需要的时间开销是很大的

```js
// 栗子
function func() {
  const obj1 = {}, obj2 = {};
  obj1.name = obj2;
  obj2.name = obj1; // 由于obj1和obj2互相引用，所以无法修改计数为0，即不会释放当前空间
  return "test";
}
func();
```

### 标记清除

**原理**
将整个垃圾回收分为两个阶段【标记 | 清除】

第一个阶段：遍历所有对象找到活动对象【可达对象】并标记；

第二个阶段：遍历所有对象清除掉没有标记的对象 & 抹掉第一个阶段所设置的标记【便于GC接下来的工作】然后回收相应的空间【将回收的空间放置在"空闲列表"上，方便后续申请使用】

**优缺点**

- 优点
  解决对象循环引用不能回收的问题
- 缺点
  1. 地址不连续 --> 空间碎片化(由于当前所回收的垃圾对象在地址上本身是不连续的，所以在回收之后他们会分散在各个角落，后续在使用的时候，刚好新的生成空间与他们的空间大小匹配，就可以使用，如果多了或者少了就不太适合使用)
  2. 不会立即回收垃圾对象

### 标记整理

**原理**

> 标记整理可以看做是标记清除的增强

第一个阶段跟标记清除完全相同；清除阶段会先执行整理，移动对象位置，使它们的地址产生连续

![img](https://pic2.zhimg.com/80/v2-ccf9640679ccb0bc4c135ba46024e249_1440w.jpg)

![img](https://pic4.zhimg.com/80/v2-07e466d8d9be64563dd0b6d187e8390f_1440w.jpg)

![img](https://pic4.zhimg.com/80/v2-45adbcccd9bad8fd0a5021f06f706b57_1440w.jpg)

### 分代回收

将内存分为**新生代存储区**和**老生代存储区**，针对不同的对象采用不同的算法

