# JavaScript 内存管理 Memory Management

### WHY 内存为什么需要管理

如果我们在写代码的时候不够了解内存管理的机制，就会编写出一些不容易察觉到的内存问题代码，这种代码多了以后给我们程序就会带来一些意想不到的BUG

### WHAT 内存管理介绍

内存：由可读写单元组成，表示一片可操作空间
管理：人为的去操作一片空间的申请、使用和释放
内存管理：开发者主动申请空间、使用空间、释放空间
管理流程：申请-使用-释放

### JS中的内存管理

申请内存空间
使用内存空间
释放内存空间

```js
// 申请
let obj = {}
// 使用
obj.name = 'obj'
// 释放
obj = null
```

# [GC算法](https://zhuanlan.zhihu.com/p/362348363)

## WHAT GC

GC 就是垃圾回收机制的简写
GC可以找到内存中的垃圾、并释放和回收空间

## GC中的垃圾

程序中不再需要使用的对象
程序中不能再访问到的对象

## WHAT GC算法

GC 是一种机制，垃圾回收器完成具体的工作
工作的内容就是查找垃圾释放空间、回收空间
算法就是工作时查找和回收所遵循的规则

## 常见GC算法

### 引用计数

**原理**
内部通过引用计数器维护当前对象的引用数，判断当前引用数是否为 0，决定是否开始 GC 工作[为 0 时则开始工作]

> 引用计数器 => 引用关系发生改变时会修改当前对象所对应的引用数字，引用数字为 0 时立即回收

```js
const obj1 = { age: 1 };
const obj2 = { age: 2 };
const obj3 = { age: 3 };
const objAge = [obj1.age, obj2.age, obj3.age]; // 由于当前对象引用了obj*中的值，所以obj*引用数字不会变为0，即不会回收
function func() {
  const a = 1,
    b = 2;
}
func(); // 函数执行完成后释放a,b
```

**优缺点**

- 优点

  1. 发现垃圾立即回收
  2. 最大限度减少程序暂停【说明 1】

- 缺点

  1. 无法回收循环引用的对象【栗子】

  2. 时间开销大【说明 2】

> 说明:
>
> 1. 当发现垃圾的时候会进行及时清理释放空间，所以保证了内存空间的大小，不会因此导致程序的暂停
> 2. 需要维护对象的数值修改，当对象很多的情况下，所需要的时间开销是很大的

```js
// 栗子
function func() {
  const obj1 = {}, obj2 = {};
  obj1.name = obj2;
  obj2.name = obj1; // 由于obj1和obj2互相引用，所以无法修改计数为0，即不会释放当前空间
  return "test";
}
func();
```

### 标记清除

**原理**
将整个垃圾回收分为两个阶段【标记 | 清除】

第一个阶段：遍历所有对象找到活动对象【可达对象】并标记；

第二个阶段：遍历所有对象清除掉没有标记的对象 & 抹掉第一个阶段所设置的标记【便于GC接下来的工作】然后回收相应的空间【将回收的空间放置在"空闲列表"上，方便后续申请使用】

**优缺点**

- 优点
  解决对象循环引用不能回收的问题
- 缺点
  1. 地址不连续 --> 空间碎片化(由于当前所回收的垃圾对象在地址上本身是不连续的，所以在回收之后他们会分散在各个角落，后续在使用的时候，刚好新的生成空间与他们的空间大小匹配，就可以使用，如果多了或者少了就不太适合使用)
  2. 不会立即回收垃圾对象

### 标记整理

**原理**

> 标记整理可以看做是标记清除的增强

第一个阶段跟标记清除完全相同；清除阶段会先执行整理，移动对象位置，使它们的地址产生连续

![img](https://pic2.zhimg.com/80/v2-ccf9640679ccb0bc4c135ba46024e249_1440w.jpg)

![img](https://pic4.zhimg.com/80/v2-07e466d8d9be64563dd0b6d187e8390f_1440w.jpg)

![img](https://pic4.zhimg.com/80/v2-45adbcccd9bad8fd0a5021f06f706b57_1440w.jpg)

### 分代回收

将内存分为**新生代存储区**和**老生代存储区**，针对不同的对象采用不同的算法

### 新生代对象的回收

**# 回收实现**

- 回收过程采用复制算法 + 标记整理
- 新生代内存区分为两个等大小空间
- 使用空间为From，空闲空间为To
- 活动对象存储于From空间
- 标记整理后将活动对象拷贝到To
- From与To交换空间完成释放

**# 回收细节说明**

- 拷贝过程中可能出现晋升【晋升就是将新生代对象移动至老生代】
- 一轮GC还存活的新生代需要晋升
- To空间的使用率超过25%需要晋升
- 使用空间换时间

### 老生代对象的回收

**# 回收实现**

- 回收过程采用标记清除、标记整理、增量标记算法
- 首先使用标记清除完成垃圾空间的回收
- 采用标记整理进行空间优化
  当新生代对象想要晋升到老生代区时 & 老生代空间又不足的情况下触发标记整理算法
- 采用增量标记进行效率优化
  \- 当垃圾进行回收的时候会阻塞JS的执行
  \- 标记增量： 将当前一整段的垃圾回收工作拆分为多个小步组合着完成当前整个回收【替代之前一口气完成的垃圾回收工作】
  \- 可以实现垃圾回收与程序执行的交替完成
  \- 提升了时间的消耗

**# 回收细节说明**

- 不适合复制算法
- 空间比较大，如果将空间一分为二，会浪费很多空间
- 老生代中的对象更多，如果采用复制算法，那么消耗时间会很长

![img](https://pic1.zhimg.com/80/v2-944652df518759c30219c4eae5583320_720w.jpg)标记增量如何优化垃圾回收

**增量标记算法的工作原理**

将当前一整段的垃圾回收工作拆分为多个小步组合完成当前的整个回收【替代之前一口气完成的垃圾回收工作】， 实现了垃圾回收与程序执行的交替完成，从而优化效率

```
在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回
收垃圾的，
也就是说只要涉及BOM及DOM就会出现循环引用问题。
```

