# V8的垃圾回收机制

### V8 垃圾回收策略

将内存分为**新生代(存活时间较短的对象)存储区**和**老生代(老生代对象就是指存活时间较长的对象,比如全局对象、闭包等)存储区**，针对不同的对象采用不同的算法

### 新生代对象的回收

**# 回收实现**

- 回收过程采用复制算法 + 标记整理
- 新生代内存区分为两个等大小空间
- 使用空间为From，空闲空间为To
- 活动对象存储于From空间
- 标记整理后将活动对象拷贝到To
- From与To交换空间完成释放

**# 回收细节说明**

- 拷贝过程中可能出现晋升【晋升就是将新生代对象移动至老生代】
- 一轮GC还存活的新生代需要晋升
- To空间的使用率超过25%需要晋升
- 使用空间换时间

### 老生代对象的回收

**# 回收实现**

- 回收过程采用标记清除、标记整理、增量标记算法
- 首先使用标记清除完成垃圾空间的回收
- 采用标记整理进行空间优化
  当新生代对象想要晋升到老生代区时 & 老生代空间又不足的情况下触发标记整理算法
- 采用增量标记进行效率优化
  \- 当垃圾进行回收的时候会阻塞JS的执行
  \- 标记增量： 将当前一整段的垃圾回收工作拆分为多个小步组合着完成当前整个回收【替代之前一口气完成的垃圾回收工作】
  \- 可以实现垃圾回收与程序执行的交替完成
  \- 提升了时间的消耗

**# 回收细节说明**

- 不适合复制算法
- 空间比较大，如果将空间一分为二，会浪费很多空间
- 老生代中的对象更多，如果采用复制算法，那么消耗时间会很长

![img](https://pic1.zhimg.com/80/v2-944652df518759c30219c4eae5583320_720w.jpg)标记增量如何优化垃圾回收

**增量标记算法的工作原理**

将当前一整段的垃圾回收工作拆分为多个小步组合完成当前的整个回收【替代之前一口气完成的垃圾回收工作】， 实现了垃圾回收与程序执行的交替完成，从而优化效率