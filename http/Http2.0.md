# HTTP/1.1 

HTTP1.1 将持久连接 keep alive 变成了默认行为，该特性使得请求完成之后，对应的连接在客户端和服务器之间还可以维持一段时间，后续发起的其他请求可以继续复用这个链接，而不需要去建立新的连接。建立连接需要完成TCP三次握手，导致创建连接耗时特别明显，但是 **队头阻塞（Head-Of-Line Blocking）** 问题依旧存在。

```text
以Chrome为例：他要求界面中每个域名只能建立6个持久连接，如果页面需要加载12张图片，前6张图片的请求通过持久连接发送给服务器，剩下的6个请求进入等待状态，整体加载时间因为这个特性变长了。我们可以使用*域名切片*来突破限制，我们把这些资源请求放到三个域名下：因为每个域名都可以有六个持久连接，现在我们网页最大可以支持18个连接同时出现，也可以使用webpack 这样的技术，将小的JS合并大的JS文件来减少请求次数，或者将小的ICON使用雪碧图的方案来合并，还可以使用内联来把图片写在样式中减少请求数量。但是这种针对HTTP1.1 的优化会打破原有缓存的优势，我们原本只需要更新一个很小的JS文件，现在客户端需要重新加载整个大的JS才能更新
```

每个HTTP是互相独立的没有状态的，我们的每个请求都在重复发送`User Agent`、 `Cookie` 等各种字段，并且因为请求自身没有状态，我们使用Cookie 或者自定义 authorization 请求头来告诉服务器端当前用户的认证信息，有的时候这些信息体积甚至高达几KB。

这一系列的特性拖慢了我们页面的打开速度

- 头信息数据是文本
- 数据体可以是文本也可以是二进制



# HTTP/2

- 头数据和数据体都是二进制（并且统称为“帧”-frame）【头信息帧-HEADER Frame 和 数据帧-DATA Frame】

- 实现了`multiplexing` 多路复用（多工）算法

  ```text
  现在我们打开一个网页，客户端和服务器端只会建立了一个连接，页面发起了一系列并发请求，客户端把这些 HTTP 消息分解为互不依赖的帧，然后在这个连接中交错发送，服务端拿到了头信息帧和数据帧后，再把它们重新组装起来，然后开始发送响应，请求的并行处理不再依赖多个连接，没有了并发的限制，宽带的利用量也随之提高
  ```

- 使用HPACK 压缩格式来压缩请求和响应标头元数据

  ```text
  一方面将每个值压缩再传输 减少体积
  另一方面，会在客户端和服务端维护一张标头字段的索引列表
  现在客户端发起了两个请求，在第一个请求中可以看到完整的HTTP报文头部；第二次请求相对于第一次请求只有PATH字段不一样，所以只发送一个PATH字段
  ```

  HPACK技术极大的减少了请求的体积

- PUSH
  服务器端主动推送资源返回给客户端

  ```text
  当客户端请求index.html之后，我们主动推送了后面需要用到的所有静态资源给客户端，客户端会将这些资源缓存下来，当后面JS下载解析完毕开始发起其他资源的时候，发现这些资源整个已经被缓存到浏览器中了。这样即使是首次访问也可以进行优化
  ```

  

**HTTP2 的缺陷**

HTTP2 还是使用TCP协议来传输的，建立连接握手的过程依旧很耗时。因为现在客户端和服务端只有一个连接，一旦发生了丢包，整个TCP中所有的请求都会被等待重传的过程阻塞

